import { ethers } from 'ethers';
import { backend } from './canisters.js';
import { get } from 'svelte/store';
import { configStore } from './stores/config.js';
import { authStore } from './stores/auth.js';
import { getProvider, getSigner, createSiweProofForVoting, getCurrentChainId } from './ethereum.js';

/**
 * Generate a storage key for ERC20 balance mapping
 * @param {string} userAddress - The user's Ethereum address
 * @param {number} slotIndex - Storage slot for balances mapping (usually 0)
 * @returns {string} The storage key as hex string
 */
function generateStorageKey(userAddress, slotIndex = 0) {
  // For ERC20 balances: keccak256(userAddress + slotIndex)
  const paddedAddress = ethers.zeroPadValue(userAddress, 32);
  const paddedSlot = ethers.zeroPadValue(ethers.toBeHex(slotIndex), 32);
  const storageKey = ethers.keccak256(paddedAddress + paddedSlot.slice(2));
  return storageKey;
}

/**
 * Generate a witness proof using eth_getProof
 * @param {Object} provider - The ethers provider to use
 * @param {string} contractAddress - The contract address
 * @param {string} userAddress - The user's address
 * @param {string|number} blockNumber - Block number for the proof
 * @returns {Promise<Object>} Witness object compatible with backend
 */
async function generateWitness(provider, contractAddress, userAddress, blockNumber) {
  try {
    // Generate storage key for ERC20 balance mapping
    const storageKey = generateStorageKey(userAddress, 0);
    
    console.log(`Generating witness for block ${blockNumber} on current network`);
    console.log(`Contract: ${contractAddress}`);
    console.log(`User: ${userAddress}`);
    console.log(`Storage key: ${storageKey}`);
    
    // Get the proof using eth_getProof with the connected provider
    const proof = await provider.send('eth_getProof', [
      contractAddress,
      [storageKey],
      ethers.toQuantity(blockNumber)
    ]);
    
    console.log('Raw proof response:', proof);
    
    // Check if storage proof exists and has valid data
    if (!proof.storageProof || proof.storageProof.length === 0) {
      throw new Error('No storage proof returned from RPC');
    }
    
    const storageProof = proof.storageProof[0];
    if (!storageProof) {
      throw new Error('Storage proof is empty');
    }
    
    // Handle null/empty storage value (user has no balance)
    const storageValue = storageProof.value || '0x0';
    
    console.log(`Storage value: ${storageValue}`);
    
    // Convert to format expected by backend
    return {
      blockHash: ethers.getBytes(proof.blockHash),
      blockNumber: BigInt(proof.blockNumber),
      userAddress: ethers.getBytes(userAddress),
      contractAddress: ethers.getBytes(contractAddress),
      storageKey: ethers.getBytes(storageKey),
      storageValue: ethers.getBytes(storageValue),
      accountProof: proof.accountProof.map(p => ethers.getBytes(p)),
      storageProof: storageProof.proof.map(p => ethers.getBytes(p))
    };
  } catch (error) {
    console.error('Failed to generate witness:', error);
    console.error('Error details:', error);
    throw new Error(`Failed to generate witness: ${error.message}`);
  }
}

/**
 * Submit a vote to the backend
 * @param {number} proposalId - The proposal ID
 * @param {'yes'|'no'|'abstain'} choice - The vote choice
 * @returns {Promise<void>}
 */
export async function submitVote(proposalId, choice) {
  try {
    // Get current state from stores
    const config = get(configStore);
    const auth = get(authStore);
    
    if (!auth.isAuthenticated || !auth.userAddress) {
      throw new Error('User not authenticated');
    }
    
    if (!config.contractAddress) {
      throw new Error('Contract address not configured');
    }
    
    // Get the already connected provider and signer
    const provider = getProvider();
    const signer = getSigner();
    
    if (!provider || !signer) {
      throw new Error('Wallet not connected properly');
    }
    
    // Get network info from connected provider
    const network = await provider.getNetwork();
    const chainId = Number(network.chainId);
    
    // Convert choice to backend format and choice text
    const voteChoice = choice === 'yes' ? { Yes: null } : 
                      choice === 'no' ? { No: null } : 
                      { Abstain: null };
    
    const choiceText = choice === 'yes' ? 'Yes' : 
                      choice === 'no' ? 'No' : 'Abstain';
    
    console.log(`üó≥Ô∏è Submitting ${choiceText} vote for proposal ${proposalId}`);
    
    // Create SIWE proof using the existing function
    console.log('Creating SIWE proof...');
    const siweProof = await createSiweProofForVoting(
      proposalId, 
      choiceText, 
      config.contractAddress, 
      chainId
    );
    
    console.log('SIWE Message:', siweProof.message);
    
    // Get current block for witness generation
    const currentBlock = await provider.getBlockNumber();
    
    // Generate witness proof
    console.log('Generating witness proof...');
    const witness = await generateWitness(
      provider,
      config.contractAddress,
      auth.userAddress,
      currentBlock
    );
    
    // Prepare vote arguments
    const voteArgs = {
      proposal_id: BigInt(proposalId),
      voter: ethers.getBytes(auth.userAddress),
      choice: voteChoice,
      siwe: siweProof,
      witness: witness
    };
    
    console.log('Submitting vote to backend...');
    
    // Submit vote to backend
    const result = await backend.icrc149_vote_proposal(voteArgs);
    
    if ('Err' in result) {
      throw new Error(`Vote submission failed: ${result.Err}`);
    }
    
    console.log('‚úÖ Vote submitted successfully!');
    return result;
    
  } catch (error) {
    console.error('Error submitting vote:', error);
    throw error;
  }
}

/**
 * Check if user has already voted on a proposal
 * @param {number} proposalId - The proposal ID
 * @returns {Promise<{hasVoted: boolean, vote: string|null}>}
 */
export async function getUserVote(proposalId) {
  try {
    const auth = get(authStore);
    
    if (!auth.isAuthenticated || !auth.userAddress) {
      return { hasVoted: false, vote: null };
    }
    
    // This would need to be implemented in the backend service
    // For now, return false - the backend will handle duplicate vote prevention
    return { hasVoted: false, vote: null };
    
  } catch (error) {
    console.error('Error checking user vote:', error);
    return { hasVoted: false, vote: null };
  }
}
